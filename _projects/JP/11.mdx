# FSM（有限状態マシン）を完全に理解する  
<br/>
---
<br/>

プログラミングをしていると、<b>FSM（Finite State Machine）</b>という言葉をよく耳にします。  
特にゲーム開発やAI、UIロジック設計では欠かせない存在です。<br/>
今日はFSMとは何か、そしてなぜ重要なのかをわかりやすく整理してみましょう。<br/>
<br/>

### 1. FSMとは？「状態と遷移の論理構造」
FSMは日本語で<b>有限状態機械</b>と呼ばれます。  
システムが取りうる状態が有限であり、特定の条件によって一つの状態から別の状態へ<b>遷移（Transition）</b>する仕組みを指します。<br/>
つまり、「今どの状態にあるのか」を記憶し、条件が合えば「別の状態に切り替わる」システムのことです。<br/>

ゲーム内のキャラクターを例に考えてみましょう。<br/>
![Image 1](/_projects/11/1.png)
<b>Idle</b>（待機中）<br/>
<b>Walk</b>（歩行中）<br/>
<b>Attack</b>（攻撃中）<br/>
<b>Dead</b>（死亡）<br/>

このように状態が決まっており、それぞれの状態で条件が満たされると次の状態へと遷移します。<br/>
<br/>
---
<br/>
<br/>

### 2. FSMの構成要素
FSMは大きく3つの要素で構成されます。<br/>

<b>1) State（状態）</b><br/>
システムが現在どの動作をしているかを表します。<br/>
例：Idle、Run、Attack、Jumpなど<br/><br/>

<b>2) Transition（遷移）</b><br/>
特定の条件が満たされると状態を切り替えるためのルールです。<br/>
例：キー入力、体力の変化、イベントの発生など<br/><br/>

<b>3) Event（イベント／トリガー）</b><br/>
状態変化を引き起こす外部からの刺激です。<br/>
例：「スペースキーを押した」→ Idle → Jumpへ遷移<br/><br/>

つまりFSMとは、「現在の状態＋条件」によって次の状態を決定する、シンプルでありながら強力な構造です。<br/>
<br/>
---
<br/>
<br/>

### 3. ゲームにおけるFSMの例
ゲーム開発においてFSMはほぼ必須です。  
プレイヤーや敵キャラクターの行動パターンを制御する際によく利用されます。<br/>

例えば、敵AIのFSM構造は次のようになります。<br/>

Idle → プレイヤーを検知したら → Chase <br/>
Chase → 攻撃範囲に入ったら → Attack <br/>
Attack → プレイヤーが逃げたら → Chase <br/>
Attack → 体力が0になったら → Dead <br/>

このように各状態は自分の役割だけを実行し、次にどの状態へ遷移するかだけを判断します。  
コードが明確になり、デバッグも容易になります。<br/>
<br/>
<br/>
---
<br/>

### 4. FSMの実装方法
FSMを実装する方法はいくつかあります。<br/>

<b>Switch文ベース</b><br/>
最もシンプルな方法で、状態をenumで定義しswitch文で分岐します。<br/>

```csharp
enum State { Idle, Move, Attack }

void Update() {
    switch (currentState) {
        case State.Idle:
            if (Input.GetKeyDown(KeyCode.W)) currentState = State.Move;
            break;
        case State.Move:
            if (Input.GetKeyDown(KeyCode.Space)) currentState = State.Attack;
            break;
        case State.Attack:
            currentState = State.Idle;
            break;
    }
}
```
シンプルですが、状態が増えるほどコードが複雑になります。<br/>
<br/>
<br/> 
---
<br/>
### 5. FSMの利点
ロジックが明確：各状態の責任が分離され、コードが整理されます。<br/>
拡張性が高い：新しい状態を追加しても既存の構造に大きな影響を与えません。<br/>
デバッグが容易：現在の状態を追跡しやすく、バグを発見しやすいです。<br/>

特にキャラクターAI、会話システム、UIの段階的な遷移など、<b>「状態が明確なロジック」</b>に非常に強力です。<br/>
<br/>
<br/>
---
<br/>

### 6. FSM vs ビヘイビアツリー
FSMはシンプルで高速ですが、状態が増えるにつれて遷移関係が複雑化しやすいという欠点があります。  
一方、ビヘイビアツリー（Behavior Tree）は階層構造でロジックを整理できるため、より柔軟で拡張性があります。<br/>

FSM → 単純な行動パターン（敵AI、UI状態管理など）に適している  <br/>
Behavior Tree → 条件分岐が多く、複雑なAIロジックに適している<br/>

どちらもゲーム開発において重要な概念ですが、プロジェクトの規模や目的に応じて使い分けることが重要です。<br/>
<br/>
<br/>
---
<br/>

# まとめ
<b>FSM</b>は、システムの動作を「状態」として分け、それぞれの状態に応じて振る舞いを制御する仕組みです。  
「現在の状態」と「入力条件」によって次の状態が決定されます。<br/>

<b>ゲームAI、UI、アニメーションロジック</b>など、段階的に変化するシステムに非常に適しています。<br/>

小規模なプロジェクトではシンプルなFSMが有効であり、  
大規模・複雑なシステムでは、状態クラスベースの設計やビヘイビアツリーを採用する方が効率的です。<br/>

FSMの概念をしっかり理解すれば、プログラムの流れをより明確に設計できるようになるでしょう。<br/>
