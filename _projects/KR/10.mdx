# 비선형 자료구조와 그 탐색기법

컴퓨터 과학에서 데이터를 효율적으로 저장하고 관리하는 것은 매우 중요합니다. 우리는 흔히 배열이나 리스트와 같은 **선형 자료구조**를 사용하지만, 실제 세상의 복잡한 관계를 표현하기 위해서는 **비선형 자료구조**가 필수적입니다. 이 글에서는 비선형 자료구조의 핵심 개념과 이를 탐색하는 두 가지 강력한 기법, 즉 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)에 대해 알아보고자 합니다.
<br/>
---
<br/>
<br/>
## 비선형 자료구조의 이해: 트리와 그래프

선형 자료구조가 데이터를 일렬로 나열하는 방식이라면, 비선형 자료구조는 데이터 요소들이 복잡한 연결 관계를 가지는 형태입니다.

### 1. 트리 (Tree)
<br/>
트리는 계층적인 구조를 가지는 비선형 자료구조입니다. 마치 나무처럼 뿌리(Root)에서 시작하여 가지(Branch)가 뻗어나가고 잎(Leaf)으로 끝나는 형태를 띠고 있습니다. 각 노드는 부모-자식 관계를 가지며, 사이클이 존재하지 않는다는 특징이 있습니다. 파일 시스템, 조직도, 의사 결정 트리 등 다양한 분야에서 활용됩니다.
<br/>
### 2. 그래프 (Graph)
<br/>
그래프는 노드(정점, Vertex)와 간선(엣지, Edge)으로 구성된 가장 일반적인 형태의 비선형 자료구조입니다. 노드들은 간선을 통해 서로 연결될 수 있으며, 트리가 특수한 형태의 그래프라고 볼 수 있습니다. 소셜 네트워크, 지도 경로 탐색, 회로 설계 등 무수히 많은 문제 해결에 사용됩니다.
<br/>
---
<br/>
<br/>
## 비선형 자료구조 탐색 기법
<br/>
복잡하게 얽힌 비선형 자료구조에서 원하는 데이터를 찾거나 모든 데이터를 방문하기 위해서는 효율적인 탐색 알고리즘이 필요합니다. 대표적으로 DFS와 BFS가 있습니다.
<br/>
### 1. 깊이 우선 탐색 (DFS: Depth-First Search)
<br/>
DFS는 이름 그대로 그래프의 깊은 부분을 우선적으로 탐색하는 알고리즘입니다. 시작 노드에서 한 방향으로 갈 수 있는 가장 먼 곳까지 탐색한 후, 더 이상 갈 곳이 없으면 되돌아와(백트래킹) 다른 경로를 탐색합니다. 미로 찾기, 경로 탐색, 위상 정렬 등에 활용됩니다.

```csharp
using System; 
using System.Collections.Generic; 

public class Graph 
{ 
    private Dictionary<string, List<string>> adj; 

    public Graph() 
    { 
        adj = new Dictionary<string, List<string>>(); 
    } 

    public void AddEdge(string u, string v) 
    { 
        if (!adj.ContainsKey(u)) adj[u] = new List<string>(); 
        if (!adj.ContainsKey(v)) adj[v] = new List<string>(); // Ensure all nodes are in adj list 
        adj[u].Add(v); 
    } 

    public List<string> DFS(string startNode) 
    { 
        HashSet<string> visited = new HashSet<string>(); 
        Stack<string> stack = new Stack<string>(); 
        List<string> result = new List<string>(); 

        stack.Push(startNode); 

        while (stack.Count > 0) 
        { 
            string node = stack.Pop(); 
            if (!visited.Contains(node)) 
            { 
                visited.Add(node); 
                result.Add(node); 

                // Get neighbors and push them to stack (reverse order for correct DFS traversal) 
                if (adj.ContainsKey(node)) 
                { 
                    List<string> neighbors = adj[node]; 
                    for (int i = neighbors.Count - 1; i >= 0; i--) 
                    { 
                        if (!visited.Contains(neighbors[i])) 
                        { 
                            stack.Push(neighbors[i]); 
                        } 
                    } 
                } 
            } 
        } 
        return result; 
    } 
} 

// 예시 그래프 
Graph graph = new Graph(); 
graph.AddEdge("A", "B"); 
graph.AddEdge("A", "C"); 
graph.AddEdge("B", "D"); 
graph.AddEdge("B", "E"); 
graph.AddEdge("C", "F"); 
graph.AddEdge("E", "F"); 

Console.WriteLine("DFS 탐색 순서: " + string.Join(", ", graph.DFS("A"))); // 출력: DFS 탐색 순서: A, C, F, B, E, D
```
<br/>
### 2. 너비 우선 탐색 (BFS: Breadth-First Search)
<br/>
BFS는 시작 노드에서 가까운 노드부터 우선적으로 탐색하는 알고리즘입니다. 시작 노드로부터 같은 레벨에 있는 노드들을 먼저 탐색한 후, 다음 레벨의 노드들을 탐색합니다. 최단 경로 찾기, 네트워크 브로드캐스팅, 소셜 네트워크에서 친구 찾기 등에 활용됩니다.

```csharp
using System;
using System.Collections.Generic;

public class Graph
{
    private Dictionary<string, List<string>> adj;

    public Graph()
    {
        adj = new Dictionary<string, List<string>>();
    }

    public void AddEdge(string u, string v)
    {
        if (!adj.ContainsKey(u)) adj[u] = new List<string>();
        if (!adj.ContainsKey(v)) adj[v] = new List<string>(); // Ensure all nodes are in adj list
        adj[u].Add(v);
    }

    public List<string> BFS(string startNode)
    {
        HashSet<string> visited = new HashSet<string>();
        Queue<string> queue = new Queue<string>();
        List<string> result = new List<string>();

        visited.Add(startNode);
        queue.Enqueue(startNode);

        while (queue.Count > 0)
        {
            string node = queue.Dequeue();
            result.Add(node);

            if (adj.ContainsKey(node))
            { 
                foreach (string neighbor in adj[node])
                {
                    if (!visited.Contains(neighbor))
                    {
                        visited.Add(neighbor);
                        queue.Enqueue(neighbor);
                    }
                }
            }
        }
        return result;
    }
}

// 예시 그래프
Graph graph = new Graph();
graph.AddEdge("A", "B");
graph.AddEdge("A", "C");
graph.AddEdge("B", "D");
graph.AddEdge("B", "E");
graph.AddEdge("C", "F");
graph.AddEdge("E", "F");

Console.WriteLine("BFS 탐색 순서: " + string.Join(", ", graph.BFS("A"))); // 출력: BFS 탐색 순서: A, B, C, D, E, F
```
<br/>
---
<br/>
## DFS/BFS 시각화 도구로 직접 체험하기
<br/>
이론적인 설명만으로는 DFS와 BFS의 동작 방식을 완벽하게 이해하기 어려울 수 있습니다. 아래 시각화 도구를 통해 직접 노드를 추가하고 연결하며, 각 알고리즘이 어떻게 노드들을 방문하는지 시각적으로 확인해 보세요.
<br/>
<DFSBFSVisualizer />
<br/>
### 사용법
<br/>
*   **노드 생성:** SVG 영역을 더블클릭하면 노드를 추가합니다.
*   **노드 이동:** 노드를 드래그하여 위치를 조정하세요.
*   **선분 연결:** 노드를 선택한 후 Shift 키를 누른 채 다른 노드를 클릭하면 선분이 연결됩니다.
*   **탐색 시작:** 시작 노드를 선택하고 DFS 또는 BFS를 선택한 후 'Run' 버튼을 누르세요.
*   **속도 조절:** 슬라이더를 이용해 애니메이션 속도를 조절할 수 있습니다.
<br/>
---
<br/>
## 결론
<br/>
비선형 자료구조는 현대 컴퓨팅 환경에서 복잡한 데이터를 모델링하고 처리하는 데 필수적인 도구입니다. DFS와 BFS는 이러한 자료구조를 탐색하는 가장 기본적인 알고리즘이며, 그 원리를 이해하는 것은 다양한 문제 해결 능력 향상에 큰 도움이 됩니다. 시각화 도구를 통해 직접 경험하며 그 차이점을 명확히 이해하시길 바랍니다.