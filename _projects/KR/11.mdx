# FSM (Finite State Machine) 완벽 이해하기
<br/>
---
<br/>

프로그래밍을 하다 보면 <b>FSM(Finite State Machine)</b>이라는 말을 자주 듣게 됩니다.
특히 게임 개발이나 인공지능, UI 로직 설계에서 빠지지 않고 등장하죠.<br/>
오늘은 FSM이 무엇이고, 왜 중요한지 쉽게 정리해볼게요.<br/>
<br/>

### 1. FSM이란? “상태와 전이의 논리 구조”
FSM은 우리말로 <b>유한 상태 기계</b>라고 부릅니다.
한 시스템이 가질 수 있는 상태들이 유한하며, 특정 조건에 따라 한 상태에서 다른 상태로 <b>전이(Transition)</b>되는 구조를 말합니다.<br/>
쉽게 말해, “지금 무슨 상태인지”를 기억하고, 조건이 맞으면 “다른 상태로 바뀌는” 시스템이죠.<br/>
예를 들어, 게임 속 캐릭터를 생각해볼까요?<br/>
![Image 1](/_projects/11/1.png)
<b>Idle</b> (대기 중)<br/>

<b>Walk</b> (걷는 중)<br/>

<b>Attack</b> (공격 중)<br/>

<b>Dead</b> (사망)<br/>

이렇게 상태가 정해져 있고, 각 상태에서 조건이 만족되면 다음 상태로 전환됩니다.<br/>
<br/>
---
<br/>
<br/>
### 2. FSM의 구성 요소
FSM은 크게 세 가지로 나눌 수 있습니다.<br/>
<b>1) State (상태)</b><br/>
시스템이 현재 어떤 동작을 하고 있는지를 나타냅니다.<br/>
예: Idle, Run, Attack, Jump 등<br/><br/>
<b>2) Transition (전이)</b><br/>
특정 조건이 만족되면 상태를 바꾸는 규칙입니다.<br/>
예: 키 입력, 체력 변화, 이벤트 발생 등<br/><br/>
<b>3) Event (이벤트/트리거)</b><br/>
상태 변화를 일으키는 외부 자극입니다.<br/>
예: “스페이스바를 눌렀다” → Idle → Jump 전환<br/><br/>
즉, FSM은 “현재 상태 + 조건”으로 다음 상태를 결정하는 단순하지만 강력한 구조입니다.<br/>
<br/>
---
<br/>
<br/>
### 3. 게임에서의 FSM 예시
게임 개발에서 FSM은 거의 필수입니다.
플레이어나 적 캐릭터의 행동 패턴을 제어할 때 가장 많이 쓰이죠.<br/>
예를 들어, 적 AI의 FSM 구조를 보면 이렇습니다.<br/>
Idle → 플레이어가 감지되면 → Chase <br/>
Chase → 공격 범위 안에 들어오면 → Attack <br/>
Attack → 플레이어가 도망가면 → Chase <br/>
Attack → 체력이 0이면 → Dead <br/>
이런 식으로 각 상태는 자기 역할만 수행하고, 다음 상태로 넘길지 여부만 판단합니다.
코드가 명확해지고, 버그 추적도 쉬워집니다.<br/>
<br/>
<br/>
---
<br/>
### 4. FSM 구현 방식
FSM을 구현하는 방법에는 여러 가지가 있습니다.<br/>
<b>Switch문 기반</b><br/>
```csharp
가장 단순한 방식으로, 상태를 enum으로 정의하고 switch문으로 분기합니다.<br/>


enum State { Idle, Move, Attack }

void Update() {
    switch (currentState) {
        case State.Idle:
            if (Input.GetKeyDown(KeyCode.W)) currentState = State.Move;
            break;
        case State.Move:
            if (Input.GetKeyDown(KeyCode.Space)) currentState = State.Attack;
            break;
        case State.Attack:
            currentState = State.Idle;
            break;
    }
}
```
간단하지만, 상태가 늘어날수록 코드가 복잡해집니다.<br/>
<br/>
---
<br/>
<br/>
### 5. FSM의 장점
로직이 명확: 각 상태의 책임이 분리되어 코드가 깔끔합니다.<br/>
확장성이 높음: 새로운 상태를 추가해도 기존 구조에 큰 영향을 주지 않습니다.<br/>
디버깅 용이: 현재 상태를 추적하기 쉬워 버그를 찾기 쉽습니다.<br/>
특히 캐릭터 AI, 대화 시스템, UI 단계 전환 등 <b>“상태가 분명한 로직”</b>에 강력합니다.<br/>
<br/>
<br/>
---
<br/>
### 6. FSM vs Behavior Tree
FSM은 간단하고 빠르지만, 상태가 많아질수록 전이 관계가 복잡해집니다.
반면, Behavior Tree는 계층 구조로 표현되어 확장에 유리하죠.<br/>
FSM → 단순한 행동 패턴 (적 AI, UI 상태 등)에 적합<br/>
Behavior Tree → 복잡한 AI나 조건 분기가 많은 시스템에 적합<br/>
둘 다 게임 개발에서 핵심적으로 쓰이지만, 목적에 따라 적절히 선택해야 합니다.<br/>
<br/>
<br/>
---
<br/>
# 정리하며
<b>FSM</b>은 시스템의 동작을 “상태”로 나누어 제어하는 구조입니다.
현재 상태와 입력 조건에 따라 다음 상태로 전이합니다.<br/>
<b>게임 AI, UI, 애니메이션 로직</b> 등 “단계적으로 변하는 시스템”에 매우 적합합니다.<br/>
작은 규모의 프로젝트에서는 단순 FSM이, 복잡한 시스템에서는 상태 클래스 기반 또는 Behavior Tree가 더 효율적입니다.<br/>
FSM을 이해하고 나면, 프로그램의 흐름을 훨씬 명확하게 설계할 수 있을 거예요.<br/>