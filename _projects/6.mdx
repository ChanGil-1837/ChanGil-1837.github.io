# float과 double의 차이

컴퓨터에는 실수를 보관할 수 있는 자료형인 float과 double이 있다.<br/>

둘의 차이는 자릿수이며, 메모리에서 보면 다음과 같이 구성된다.<br/>

<b>float</b> : 32비트 (부호 1, 지수 8, 가수 23)<br/>
<b>double</b> : 64비트 (부호 1, 지수 11, 가수 52)<br/>

<br/>
<br/>
---
<br/>
## 부동소수점의 구조

맨 첫 비트는 양수/음수를 표시한다.  
그다음 비트들은 지수(2의 몇 제곱인지)와 가수(소수 부분)로 나뉜다.<br/>

<b>부호</b> : 양수는 0, 음수는 1<br/>
<b>지수</b> : 2의 몇 제곱으로 표현할지 나타냄<br/>
<b>가수</b> : 실제 소수 부분<br/>

<br/>

예시: 5.125 를 저장하고 싶다면<br/>

5.125를 2진수로 바꾸면 101.001이 된다.<br/>
이를 컴퓨터가 이해할 수 있게 바꾸면 1.01001 × 2^2 형태가 된다.<br/>

부호 비트: 0 (양수이므로)<br/>
지수 비트: 2를 저장해야 하는데, 여기엔 Bias(127)를 더해줘야 한다.<br/>
Bias는 음수 지수도 표현할 수 있게 하기 위한 장치다.<br/>

따라서 2 + 127 = 129 → 10000001<br/>
가수 비트: 소수 부분 01001을 채워 넣는다.<br/>

결과적으로 5.125를 float에 저장하면:<br/>
0 10000001 01001000000000000000000<br/>

<br/>
<br/>
---
<br/>
## 부동소수점의 한계

하지만 여기서 문제가 생긴다.<br/>
예를 들어, 0.125는 2진수로 딱 떨어져 0.001로 저장할 수 있지만,<br/>
0.1은 0.00011001100110011... 식으로 무한히 반복되는 수라서 컴퓨터가 딱 맞게 저장할 수 없다.<br/>
그래서 뒤를 잘라버리고 저장하고, 이 때문에 오차가 발생한다.<br/>

```csharp
using System;
namespace HelloWorld
{
    public class Program
    {
        static void Main(string[] args)
        {
            float a = 0.1f;
            float b = 1.1f;
            Console.WriteLine(a + b == 1.2);
        }
    }
}
```
그래서 위의 코드의 실행결과를 보게되면<br/>
```graphql
chanho@chanhos-MacBook-Pro ConsoleApp1 % dotnet run
False
```
이런 0.1+1.1 과 1.2 는 다르다는 결과가 나타나게된다.<br/>
이는 0.1을 정확히 저장할 수 없기 때문에 발생하는 현상이다.<br/>
<br/>
<br/>
---
<br/>
## 정리<br/>
따라서 소수점 계산이 필요한 경우, 가능하다면 정수 형태로 변환해 저장하고 계산하는 것이 더 안전하다.<br/>
예를 들어, 돈을 다룰 때는 원 단위 대신 1달러 = 100센트 같은 식으로 정수로 바꿔서 처리하는 방식이 자주 쓰인다.<br/>