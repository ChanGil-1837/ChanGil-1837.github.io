# floatとdoubleの違い

コンピュータには、実数を格納できるデータ型であるfloatとdoubleがあります。<br/>

両者の違いは桁数であり、メモリ上では次のように構成されます。<br/>

**float** : 32ビット（符号1、指数8、仮数23）<br/>
**double** : 64ビット（符号1、指数11、仮数52）<br/>

<br/>
<br/>
---
<br/>
## 浮動小数点数の構造

最初のビットは、正負を表します。
その後のビットは、指数（2の何乗か）と仮数（小数部分）に分かれます。<br/>

**符号** : 正数は0、負数は1<br/>
**指数** : 2の何乗で表現するかを示す<br/>
**仮数** : 実際の小数部分<br/>

<br/>

**例：5.125を保存したい場合**<br/>

5.125を2進数に変換すると101.001になります。<br/>
これをコンピュータが理解できるように変換すると、1.01001 × 2^2の形になります。<br/>

**符号ビット**：0（正数なので）<br/>
**指数ビット**：2を保存する必要がありますが、ここにはBias（127）を加える必要があります。<br/>
Biasは、負の指数も表現できるようにするための仕組みです。<br/>

したがって、2 + 127 = 129 → 10000001<br/>
**仮数ビット**：小数部分の01001を埋めます。<br/>

結果として、5.125をfloatに保存すると、次のようになります。<br/>
0 10000001 01001000000000000000000<br/>

<br/>
<br/>
---
<br/>
## 浮動小数点数の限界

しかし、ここで問題が発生します。<br/>
例えば、0.125は2進数でちょうど0.001として保存できますが、<br/>
0.1は0.00011001100110011...のように無限に繰り返される数なので、コンピュータは正確に保存することができません。<br/>
そのため、後ろを切り捨てて保存し、そのために誤差が発生します。<br/>

```csharp
using System;
namespace HelloWorld
{
    public class Program
    {
        static void Main(string[] args)
        {
            float a = 0.1f;
            float b = 1.1f;
            Console.WriteLine(a + b == 1.2);
        }
    }
}
```
したがって、上記のコードの実行結果を見ると、<br/>
```graphql
chanho@chanhos-MacBook-Pro ConsoleApp1 % dotnet run
False
```
このように0.1 + 1.1と1.2は異なるという結果が表示されます。<br/>
これは、0.1を正確に保存できないために発生する現象です。<br/>
<br/>
<br/>
---
<br/>
## まとめ
したがって、小数点以下の計算が必要な場合は、可能であれば整数形式に変換して保存し、計算する方が安全です。<br/>
例えば、お金を扱う際には、ウォン単位の代わりに1ドル=100セントのように整数に変換して処理する方法がよく使われます。<br/>